# CH03 애그리거트

## 애그리거트

계속 비슷한 설명이 이어지는데 이번 장은 애그리거트에 대해서 상세한 설명이 있었다. 중복되는 내용을 제외하고 나머지만 정리한다.

애그리거트는 도메인 이해를 쉽게 이해하는데 도움이 된다. 저수준 레벨에서 도메인을 이해하기 전에 큰 단위들로 먼저 전체 도메인을 조망할 수 있게 해주는 단위이다.

앞에서도 다뤘지만 애그리거트에 속한 구성요소(ENTITY, VALUE)는 애그리거트와 함께 생성되고 소멸된다. 즉, 동일하거나 유사한 라이프사이클을 갖고 있다.

책에서 주의를 주고 있는 점이 있는데 바로 'A가 B를 갖는다'고 해서 반드시 A와 B가 같은 애그리거트는 아니라는 것이다. 책에서 예시로 들고 있는 것은 Product 와 Review 인데 둘의 생성 및 변경 주체가 다르기도 하고 유사한 라이프사이클을 갖고 있지도 않다. 그래서 같은 애그리거트라고 할 수 없다. 하지만 Product 는 Review 가지는 구조이긴 하다.

그래서 애그리거트 단위를 구성할 때 이러한 점을 유의하여야 한다. 저자 경험상 대부분의 애그리거트가 한 개의 엔티티 객체만 갖는 경우가 많았고 두 개 이상의 엔티티로 구성되는 애그리거트는 드물었다고 한다.



## 애그리거트 루트

애그리거트 루트라는 용어를 루트 엔티티와 자꾸 혼용 되고 있는데, 앞에서도 살펴 보았듯이 애그리거트 내에서 대표로서 애그리거트가 제공해야할 기능을 제공하고 상태를 갖고 일관된 규칙을 보장하는 역할을 하는 엔티티가 루트 엔티티이며 애그리거트 루트라고도 부른다.

각 애그리거트에는 오직 하나의 루트 엔티티가 존재하며 이 루트 엔티티가 애그리거트에 속한 모든 ENTITY, VALUE 들에 접근하여 애그리거트 전체가 제공해줘야할 기능을 처리한다.

### 도메인 규칙과 일관성

다시 강조하지만 루트 엔티티의 핵심 책임은 애그리거트의 일관성을 유지하는 것이다. 일관성을 유지한다는 것은 해당 애그리거트에 속한 ENTITY, VALUE 들이 가진 고유의 도메인 규칙이 외부에 의해서 어겨지지 않고 각자의 규칙대로 일관되게 처리시킨다는 것을 의미한다.

루트 엔티티의 역할이 '애그리거트의 일관성을 유지하는 것'이라는 것을 조금 더 쉽게 이해하기 위해서 일관성을 깨트리는 예시를 살펴보자. 주문 애그리거트에서 '배송지 변경은 배송이 아직 시작하기 전에만 가능하다'는 도메인 규칙이 있다고 했을때, 아래와 같이 코드를 작성할 수 있다.

```java
public class Order {
    
    public void changeShippingInfo(ShippingInfo newShippingInfo) {
        verifyNotYetShipped();
        setShippingInfo(newShippingInfo);
    }

    private void verifyNotYetShipped(){
        if(state != OrderState.PAYMENT_WAITING || state != OrderState.PREPARING) 
            throw new IllegalArgumentException("already shipped");
    }
}
```

Order의 changeShippingInfo() 만을 통해서 기능을 수행하면 무조건 verifyNotYetShipped()를 거쳐서 일관된 도메인 규칙을 지킬 수 있다. 하지만 여기서 아래와 같이 외부에 노출된 setter 로 배송지를 마음대로 바꾸게 되면 verifyNotYetShipped() 를 통해서 적용하는 도메인 규칙을 적용하지 못하게 된다. 즉, 도메인 규칙의 일관성이 깨지게 되는 것이다.

```java
ShippingInfo si = order.getShippingInfo();
si.setAddress(newAddress);
```

그리고 VALUE 를 불변으로 만들지 않으면 외부에서의 상태 변경이 가능해지기 때문에 위와 비슷한 맥락에서 일관성이 깨질 여지가 발생한다.

정리하자면 애그리거트의 루트 엔티티는 애그리거트의 일관성을 유지시키는데 핵심 책임이 있고 이를 위해서는 아래 두 가지 원칙을 지켜야 한다.

1. 필드를 변경하는 setter 를 public 으로 노출시키면 안된다.
2. VALUE 는 무조건 불변 객체로 만든다.

### 트랜잭션의 범위







































