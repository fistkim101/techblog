# CH04 리포지터리와 모델 구현

## JPA를 이용한 리포지터리 구현

스프링 데이터 JPA 를 활용하지 않은 경우를 이야기하며 핵심 정리 포인트는 DIP 에서 살펴본 바와 같이 도메인 계층에 추상화된 리포지터리가 있고 인프라스트럭처 계층에서 이를 실제 구현해야한다는 것이다.(아래 그림 참고)

<figure><img src="../../.gitbook/assets/image (7).png" alt=""><figcaption></figcaption></figure>

## 스프링 데이터 JPA를 이용한 리포지터리 구현

위 'JPA를 이용한 리포지터리 구현'에서 살펴본 바와 같이 모듈의 위치는 DDD 원칙을 그대로 따른다. 이 부분에서 책에서는 일반적으로 스프링 데이터 JPA 가 제공하는 메소드들의 시그니처와 기능에 대해서 살펴보았는데 스프링 데이터 JPA에 관한 일반적인 내용이므로 따로 정리하지 않는다.



## 매핑 구현

애그리거트 내에서 엔티티와 밸류의 매핑을 어떻게 처리할 것인지 JPA 를 사용한다는 가정에서 여러 경우들에 대한 예시들을 살펴보았다. JPA 에서 제공해주는 여러 어노테이션(@Embbeded, @Embeddable, @ElementCollection, @CollectionTable, @SecondaryTable)으로 여러 경우를 소화해낼 수 있다. 각 케이스에 대한 정리는 JPA 기술에 관한 내용과도 같아서 따로 하지 않는다.

내가 기억해두면 좋을 내용들은 아래와 같다.

1. 별도의 테이블을 사용한다고 해서 엔티티인 것은 아니다. 별도의 테이블을 사용해도 VALUE 로 구분될 수 있다. (똑같은 언급을 계속 하지만 높은 확률로 하나의 애그리거트는 하나의 엔티티를 가진다)
2. VALUE 이지만 @Entity 로 매핑해서 처리할 수 있다.(편의 목적 혹은 팀 표준 등의 이유)

그런데 VALUE 를 1번처럼 별도 테이블로 관리하되 ENTITY 로 만들지 않는 경우 성능상 문제가 있는 경우가 있다. 예를 들어서 1:N 관계에서 N의 정보 하나만 변경해도 모든 N을 삭제하고 다시 삽입하는 식으로 성능성 비효율이 발생한다.

그래서 개인적으로 VALUE 이지만 @Entity 로 설정해주고 관리해주되 Cascade 옵션을 잘 활용하는 방식이 더 좋을 것 같다. 따로 커스텀 어노테이션을 만들어서 VALUE 임을 명시적으로 드러내주는 것도 좋을 것 같다.

난 지금껏 VALUE 이지만 @Entity 로 설정하고 구현해왔는데, 이 방식을 그대로 사용하는 것이 좋겠다. 다만, 커스텀 어노테이션을 만들어서 루트 엔티티와 VALUE 를 분명히 구분해주면 좋을 것 같다. 결론적으로 나는 아래와 같은 방식을 취할 것이다.

1. VALUE 라고 해도 @Entity 로 관리한다.
2. 커스텀 어노테이션을 만들어서 루트 엔티티와 VALUE 를 명시적으로 구분해준다.

@Entity 와 DDD 에서 말하는 Entity 를 구분해야 위의 개념들이 혼란스럽지 않다.





