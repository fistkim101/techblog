# 들어가며

추천사 및 서문의 내용이 생각보다 좋아서 몇몇 부분만 정리한다.



## 아키텍처 라는 단어의 정의에 대해서 다시 한번 짚어보자

단순히 '설계'라고만 인식하고 있었는데, 막상 구체적인 문구로 풀어서 스스로 설명해보려하니 마음에 들 만큼 명확한 구체적인 문장이 떠오르지 않았다.

위키에서는 아래와 같이 나온다.

> 소프트웨어 구조 또는 소프트웨어 아키텍처(software architecture)는 [소프트웨어](https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4)의 구성요소들 사이에서 유기적 관계를 표현하고 소프트웨어의 설계와 업그레이드를 통제하는 지침과 원칙이다.

책의 추천사에는 이런 글이 있다.

> 아키텍처는 시스템을 구체화하는 중요한 설계 결정을 표현하며, 그 결정의 중요도는 변경에 드는 비용으로 측정된다.

만약 나에게 누가 소프트웨어 아키텍처에 대해서 설명해보라고 하면 '시스템을 구성하는 구성요소들이 서로 어떻게 협력할지에 관한 원칙 및 규칙'이라고 할 것 같고, 어떤 설계가 좋은 설계냐고 묻는다면 '수정 비용이 적은' 설계가 좋은 설계라고 할 것 같다.

설계의 정의와 좋은 설계의 기준 모두 '객체지향의 사실과 오해'에서 학습한 패러다임으로 설명이 되는 것 같다.(그만큼 좋은 책이었던 것 같다.)



## 좋은 설계를 해야하는 이유

### 좋은 설계는 비싸다

> 좋은 아키텍처가 비싸다는 생각이 든다면,
>
> 나쁜 아키텍처를 시도해 보라

라는 문구가 책에 있는데, '고생한번 해보기 전엔 이게 진짜 필요한 것인지 체감할 수 없다'는 말로도 풀이될 수 있을 것 같다. 좋은 아키텍처가 비싸다는 것은 그만큼 '별 생각 없이', '늘 하던대로' 하는 것이 싸다는 말이기도 하다.

좋은 아키텍처는 아키텍처 원칙을 철저히 따라야 하고, 설계하는 과정에서 고민의 밀도가 더 높기 때문에 비쌀 수 밖에 없다.



### 비싸지만 좋은 설계를 고집해야 한다. 왜?

그렇다면 굳이 이렇게 비용을 치뤄가면서 좋은 설계를 고집해야할까? 책의 초반부에서도 그렇고 경험에 비추어봐도 그렇고 좋은 설계, 정확히는 수정 비용이 최대한 '저렴할 가능성이 큰' 설계가 결국 계속해서 큰 힘을 발휘한다.

하나의 시스템이 작동하고 이것이 실제로 비즈니스 세계에서 성과를 내기 시작하면 쉽사리 이것을 갈아 엎거나 대단위로 리팩토링 할 수 없다. 현실적인 리소스도 한정적이고 이미 잘 되고 있는 것을 굳이 바꾼다는 것은 회사에서 쉽게 일어나지 않는다. 그래서 처음 만들때 좋은 설계로 잘 만들어야 한다.

여기서 대전제는 '바뀐다'는 것이다. 현실 세계에서는 비즈니스의 요구사항이 바뀔 여지가 크다. 결국 시스템은 현실의 문제를 위한 도구적 관점에서 존재한다. 태생적으로 그럴 수 밖에 없다. 코드는 예술과 비슷한 맥락에서 예술을 추구해야하지만 태생적으로 철저하게 쌀과 밥을 위해서 존재한다.(적어도 실무에서는)

그래서 결국 근본적으로 현실의 도메인을 해결하기 위한 도구적 수단으로 존재하고, 현실은 변화하기 때문에 시스템도 이에 맞게 변할 수 밖에 없다. 너무 추상적으로 둘러 이야기 했는데 노골적으로 표현해서 '요구사항은 무조건 변한다'는 것이다. 무조건. 안 변할 것 같아도 변한다고 가정하고 시스템을 구현해야한다.

여기서 결국 유지 비용, 수정 비용에 대한 이슈가 생겨난다. 이 맥락에서 시스템의 현실 요구에 대한 수용성도 거론될 수 있다. 이러한 이유에서 조금 비싸더라도 우리는 '좋은 설계'를 추구해야한다.



## 아키텍처는 과정이다

> 아키텍처는 종착지가 아니라 여정에 더 가까우며, 고정된 산출물이 아니라 계속된 탐구 과정에 더 가까움을 이해해야 좋은 아키텍처가 만들어진다.

이 문구가 정말 개인적으로 인사이트가 엄청나게 담긴 문구라는 생각이 든다. 계속해서 좋은 아키텍처란 수정 비용이 저렴하고 수용성이 큰 아키텍처라고 말하고 있는데, 이 맥락과 그대로 맞닿아 있는 것이다.

즉, 좋은 아키텍처가 되려면 '이러저러한 원칙과 공식대로 구현하면 끝'이 아니라 이게 이제 시작인거고, 실제로 이 아키텍처가 변화가 많이 발생하는 현실을 얼마만큼의 수정 비용을 치르고 잘 소화해 내는지를 계속해서 살펴봐야 한다는 것이다.

아키텍처는 스스로 이러한 변화들을 소화해 내면서 '좋은' 아키텍처임을 증명해야하고 개발자는 이것을 처음부터 끝까지 책임지고 수행하며 '좋은' 아키텍처가 되도록 만들어야한다. 한번 만들어놓으면 '땡'이 아니란 것이다.

이런 컨텍스트가 책에 자세히 적혀있는 것은 아니고 그냥 내가 이 부분에서 느낀 생각이다. 아마 이런 생각으로 저런 문구를 써놓지 않았을까 싶다.



## 아키텍처는 시대를 관통한다

로버트 C 마틴이 1964년에 처음 코드를 작성했다고 하는데 시대 차이가 체감이 났다. 내가 태어나기도 전에 이 사람은 코드를 짰다.

아무튼 엉클밥이 정말 온갖 시스템(책에서 나오는데 임베디드, 실시간 웹, 콘솔 , 공정 저에, 게임, 회계, 그림 그리기 등)을 다 만들어 봤는데 결론적으로 아키텍처는 동일하다는 것을 느꼈다고 한다.

뭐 설명이 엄청 많은데 다 떼고 요약하자면 아래가 핵심이다.

> * 코드는 여전히 순차, 분기, 반복의 집합체일 뿐이다.
> * 하드웨어도 아주 발전했고, 언어도 발전했다. 하지만 컴퓨터 프로그래밍을 이루는 기본 구성 요소는 조금도 바뀌지 않았다.
> * 소프트웨어 아키텍처의 규칙이란 프로그램의 구성요소를 정렬하고 조립하는 방법에 관한 규칙이다. 그리고 이 구성요소가 보편적이며 변하지 않았으므로, 이들을 정렬하는 규칙 역시도 보편적이며 변한 것이 없다.

그렇다고 한다. 이건 인문학적으로 보면 아마도 정말 옛날 시대 배경의 '고전'들이 아직도 오늘날에도 높은 가치로 대우받는 것과 같은 맥락이 아닐까 싶다. 결국 구체적인 것을 다 떼고 추상적인 레이어에서 보면 감정을 터칭하는 서사와 인간의 희노애락을 다루는거니까.

이런 맥락에서 소프트웨어도 결국 예나 지금이나 가만보면 다 똑같더라. 그러니 아키텍처도 다 똑같다. 이 말인것으로 이해했다. 똑같지만 발전을 하고 있는 것이니 완전히 똑같다기 보다는 '아키텍처가 추구해야할 가치'는 똑같다가 더 구체적인 표현 같다.

딱 서문의 마지막줄에 아래와 같이 적혀있다.

> 그리고 이 책은 바로 이 규칙, 세월이 흘러도 변치 않는 그 규칙에 관한 것이다.

책을 보면서 계속 근본적인 방향이 바로 이것임을 인지하면서 읽으면 내용을 좀 더 잘 이해할 수 있지 않을까 싶다.
