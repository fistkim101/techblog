# 13장 컴포넌트 응집도

## 13장 핵심 내용 방향성(숲을 먼저 보자)

이번 장이 대부분 막연히 봐버리면 '다 당연한 이야기 아니야?' 이러고 끝날 수 있어서 큰 방향성을 짚고 넘어가고자 소제목을 굳이 분류했다. 이번 장의 핵심 방향은 아래와 같다.

> 어떤 클래스를 어떤 컴포넌트에 포함시켜야 할까?

위 고민에 대한 기준들로 삼을 수 있는 원칙들을 학습한다. 원칙들은 아래와 같다. 외울 필요는 전혀 없다. 단지 이러한 구분된 개념들을 내가 이해하고 배포 단위의 경계를 지을때(직관적인 표현으로는 서버를 나눌때 정도가 되겠다) 도메인 성격 말고도 같이 고려해야할 원칙들로 삼을만한 것들이라서 필요시 다시 찾아보면 좋을 것 같다.

* REP: 재사용/릴리즈 등가 원칙 Reuse/Release Equivalence Principle
* CCP: 공통 폐쇄 원칙 Common Closure Principle
* CRP: 공통 재사용 원칙 Common Reuse Principle



## REP: 재사용/릴리즈 등가 원칙 Reuse/Release Equivalence Principle

> 재사용 단위는 릴리즈 단위와 같다.

나만 그런 것일 수 있지만 이 문장 자체도 너무 모호하게 느껴졌다. 당연히 맞는 말 같기도 하고 무슨 말인지 확 와닿지 않기도 하고.

'재사용 단위' 에서 '재' 를 때고 '사용단위' 에 포커스를 맞추면 이해하기가 조금 쉽다.(내 이해가 맞다면) 어차피 사용 단위라는게 재사용 단위이다. 예를 들어서 롬복1.0 을 사용한다고 치자. 롬복1.0 을 구성하는 1,2,3,4,5 가 있다고 치자. 이 1,2,3,4,5 는 항상 함께 디벨롭되고 함께 릴리즈 된다. 그리고 함께 '사용' 또는 '재사용' 된다. 이게 이 원칙의 의미이다.

그래서 재사용 단위와 릴리즈 단위가 같다는 의미이다. 이렇게 풀어보면 더 그냥 당연한 말 같아 보인다. 책에선 아래와 같이 말하고 있다.

> 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리즈 할 수 있어야 한다. 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 하며, 동일한 릴리즈로 추적 관리되고, 동일한 릴리즈 문서에 포함되어야 한다는 사실은 컴포넌트 제작자 입장이나 사용자 입장에서도 이치에 맞는 이야기다.

직관적으로 너무 당연히 맞는 이야기를 굳이 \~법칙 이라고 이름 붙인 느낌이긴하다.&#x20;



## CCP: 공통 폐쇄 원칙 Common Closure Principle

> 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.

이건 결국 SRP 이야기이다. 변경의 트리거 주체가 둘 이상인 것을 하나로 묶지 않아야 한다는 이야기이다. 책에서도 SRP 를 컴포넌트 관점에서 다시 썼다고 말하고 있다.

이 CCP 라는 원칙은 유지보수 차원에서 유리하도록 같이 변경되어야 할 것들을 한데 모으고 서로 최대한 멀리하고 떨어트려도 무방한 것들은 분리하도록 하라는 내용이다. 그래야 분리 수정/발전 시키기 용이하니까.

> ... 따라서 변경이 필요한 요구사항이 발생했을 때 그 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 가능성이 확실히 높아진다.



## CRP: 공통 재사용 원칙 Common Reuse Principle

> 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.

이건 원칙 네이밍이 왜 이렇게 된 건지 아직도 잘 이해가 안간다. 공통폐쇄는 말 그대로 비슷한 것끼리 응집성을 강화시키다 보면 자기끼리 뭉치고 외부에 폐쇄적이기에 공통폐쇄가 맞는데 이건 네이밍이 약간 이상하다.

책 내용상 ISP 와 맥락이 일치한다.

> 어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에는 의존성이 생겨난다. 어쩌면 사용하는 컴포넌트가 사용되는 컴포넌트에서 단 하나의 클래스만 사용할 수도 있다. 그렇다고 해서 의존성은 조금도 약해지지 않는다. 사용하는 컴포넌트는 사용되는 컴포넌트에 여전히 의존한다.
>
> 따라서 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다.

이 말은 의존해버리는 순간 의존의 범위를 떠나서 의존성이 생겨버리니까 애초에 컴포넌트를 설계할 때 결합구조를 잘 짜야한다는 것이다. 이 맥락에서는 결합구조를 보수적으로 가져가라는 말과 같다.

위 사례를 보면 A가 B에 의존하고, B가 1,2,3,4,5... 10 으로 구성되어 있을때. A가 B의 1에만 의존하고 있다고 치자. 그러면 의존도가 낮은데도 의존 자체는 이미 생겨버렸다는 것이다. 그래서 B를 설계할때 1이 꼭 B에 포함되어야 하는지, 분리할 수는 없는지 등을 고민해야한다는 것이다.

> 따라서 CRP는 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 한데 묶어서는 안 되는지에 대해서 훨씬 더 많은 것을 이야기 한다.
