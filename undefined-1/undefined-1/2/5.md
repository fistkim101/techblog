# 5장 객체 지향 프로그래밍

이 주제는 워낙 많이 다뤄지는 내용이라서 별로 정리할 것이 없을 것 같았는데 책 내용중 좀 특이한 것들도 있었어서 읽는 재미가 있었다. 그런데 좀 뻔한 내용도 섞여 있기는 하다.



## 캡슐화, 상속, 다형성이 객체 지향 핵심 키워드라는데 저자 생각에는 이게 C 때부터 존재했다고 한다

100% 일치하게는 아니지만 각각의 개념이 C 에서부터 존재했다고 하며 사례들을 들고 있다. 하지만 한편으로는 그러한 구현 방식이 문제점들도 있음을 지적하고는 있다. 여기서 갑자기 다형성 하나에 대해서 파고드는데 책의 전개가 조금 뜬금 없긴 하다.



## 다형성이 가진 힘

> 플러그인 아키텍처는 이처럼 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다.

DIP 언급을 위한 빌드업인데 메타적인 관점에서 직접 의존이 아니라 중간에 '플러그인' 을 둠으로써 그것이 중간의 경계로 존재하며 호환의 문제를 해결해 주고 있음을 강조한다.



## 의존성 역전

이건 다른 곳에서 정리를 여러번 했었어서 개념 자체에 대해서는 넘어간다.(책에서는 자세하게 말하고 있다.)

핵심은 의존성 역전에 대해서 '와 의존성이 역전되었구나' 라고 생각할 것이 아니라 의존성 역전을 '왜' 사용해야 하는 지에 대해서 이해하는 것이 중요하다. DIP를 사용하지 않았을때 어떤 것이 문제고 DIP 사용함으로써 무엇이 해결 되는 지를 알아야 한다.

> OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 갖는다. 즉, 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한하지 않는다. 호출하는 모듈이든 아니면 호출 받는 모듈이든 관계없이 소프트웨어 아키텍트는 소스 코드 의존성을 원하는 방향으로 설정할 수 있다.

의존성 역전을 구사하면 의존의 방향을 원하는 대로 만들 수 있다. 의존의 방향을 바꾸는게 뭐가 좋은데? 에 대한 대답이 핵심인데, 쉽게 말해서 '휘둘리지 않을' 수 있다. 의존하는 구체적인 것은 바뀔 여지가 크고 그것이 바뀌면 변경의 여파까지 받을 수 있는데 중간에 경계를 둠으로써 의존 방향을 역전 시키고 이 경계 덕분에 이 명세만 잘 따르면 외부의 변경에 절대 휘둘리지 않을 수 있다.

또한 루즈 커플링을 달성했기 때문에 외부와 내부를 각각 다른 사람이 독립적으로 개발해도(책의 표현으로는 '개발 독립성') 효율적인 개발이 가능하다.
