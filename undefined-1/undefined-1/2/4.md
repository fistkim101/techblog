# 4장 구조적 프로그래밍

## 구조적 프로그래밍의 시작 - 유클리드 계층구조

데이크스트라라는 아주 옛날의 사람이 유클리드 계층 구조를 사용하는 방식을 프로그래밍에도 적용할 수 있다고 믿었다.

이거 좀 설명이 복잡한데 단순하게 표현하면 참일 수 밖에 없는 구조를 코드와 결합하면 시스템 전체(코드 전체)가 올바르다고도 말할 수 있지 않을까? 라는 믿음이 있었다는 의미이다.

이걸 증명하는 과정에서 goto 가 때로는 '참'을 깨트리는 것을 발견했고, 한편으로 순차 실행, 분기, 반복 이라는 세 가지 제어 구조만 활용하면 모든 프로그램을 표현할 수 있고 이것이 유클리드 계층 구조를 만족시킬 수 있다고 증명해냈다.

내가 이해한 것이 맞을지는 잘 모르겠으나 이 부분의 내용이 너무 추상적이라서 딱 정리된 문장으로 표현하자면 아래와 같다.

> 순차실행, 분기, 반복 이라는 세 종류의 제어 구조로 모든 프로그램을 만들 수 있고 이렇게 만들어진 '참'인 부분들을 모아서 '참' 인 시스템을 만들 수 있다.

구조적 프로그래밍은 결국 거대한 프로그램을 작은 단위로도 바라볼 수 있게 해주는(=바라봐도 된다는) 관점을 제공해주는 패러다임인 것이다.



## 기능적 분해

> 구조적 프로그래밍 덕분에 시스템을 증명 가능한 더 작은 단위로 분해 할 수 있게 되었다.

구조적 프로그래밍의 효용의 핵심은 결국 위 문장이다. 그래서 덕분에 커다란 것을 작게 작게 분해해서 바라볼 수 있게 되었다. 이것은 곧 거대한 시스템을 모듈과 컴포넌트 단위로 나눌 수 있고, 분해된 각각의 단위는 옳게 작동함을 증명할 수 있는 단위가 되는 것이다.



## 테스트에 관한 관점

이 내용이 아주 재밌는 관점이었다.

> 데이크스트라는 "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다"고 말한 적이 있다. 다시 말해 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.

이거 처음엔 응? 해도 가만히 보면 맞는 말임을 알 수 있다. 이게 맞는 말이라는 증거는 테스트 커버리지 100%에 아무리 완벽하게 테스트 잘해놔도 생각하지 못한 엣지 케이스 등에 의해 의도치 않은 버그가 발생하는 사례이다.

그래서 테스트는 '올바르게 작동하지 않음'을 증명하기 위한 최선이 되어야 하고, 이 최선이 실패함으로써 역설적이게도 프로그램이 적어도 기능의 목표에 부합은 한다는 것을 증명하게 된다. 이거 진짜 엄청난 인사이트가 담긴 말이다.

> 구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다. 그러고 나서 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도한다. 이처럼 거짓임을 증명하려는 테스트가 실패한다면, 이 기능들은 목표에 부합할 만큼은 충분히 참이라고 여기게 된다.



## 구조적 프로그래밍이 그래서 아키텍처와 어떤 관계가 있다는 걸까

구조적 프로그래밍은 결국 '분해'라는 단어로 축약할 수 있다는 것을 알 수 있다. 이를 아키텍처에 적용해보면 아키텍처가 '분해'될 수 있고 분해된 각각은 모두 '증명 가능'해야 한다는 것을 추론해볼 수 있다.
