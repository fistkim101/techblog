# 9장 LSP: 리스코프 치환 원칙

## LSP 정의

> 리스코프의 '행동적 하위형'이라는 개념은 '가변 객체의 치환성'이라는 개념을 정의한다. 즉 자료형 ![S](https://wikimedia.org/api/rest\_v1/media/math/render/svg/4611d85173cd3b508e67077d4a1252c9c05abca2)가 자료형 ![T](https://wikimedia.org/api/rest\_v1/media/math/render/svg/ec7200acd984a1d3a3d7dc455e262fbe54f7f6e0)의 하위형이라면, 프로그램에서 자료형 ![T](https://wikimedia.org/api/rest\_v1/media/math/render/svg/ec7200acd984a1d3a3d7dc455e262fbe54f7f6e0)의 객체는 프로그램의 속성을 변경하지 않고 자료형 ![S](https://wikimedia.org/api/rest\_v1/media/math/render/svg/4611d85173cd3b508e67077d4a1252c9c05abca2)의 객체로 교체할 수 있다.&#x20;

책의 정의가 너무 복잡하게 꼬여있어서 위키 정의를 가져왔다. 구현체는 의존 대상인 추상 모듈을 얼마든지 대체할 수 있어야 한다는 이야기다.



## LSP 를 위반해보자. 정사각형/직사각형 문제

<figure><img src="../../../.gitbook/assets/2023. 4. 5. - 0 9 (1).jpg" alt=""><figcaption></figcaption></figure>

여기서 Square 가 Rectangle 을 치환하지 못하는 것이 LSP 를 위배하는 것인데 실제로 치환하지 못한다. 왜냐하면 직사각형에서는 높이와 너비가 각각 따로 변경이 가능해야 하는데 정사각형은 하나만 바뀌어도 같이 바뀌어야 하기 때문이다.



## LSP 와 아키텍처는 무슨 관계인가

구현체를 사용하는 곳에서 어떤 구현체가 오든 잘 동작 하길 기대하고 이를 호출하기 때문이다. 즉, 구현체가 무엇이 오든 잘 치환하여 역할을 할 것임을 전제하고 호출을 하는데 구현체에 따라 어떤 것은 역할을 완벽히 수행하지 못하는, 즉 치환하지 못하는 일이 발생하면 시스템이 문제가 있다고 할 수 있다.

그래서 좋은 아키텍처에는 추상화가 사용되지만 추상화가 사용 되었다는 것은 곧 LSP 를 정확하게 지켜야만 제대로된 시스템 동작을 기대할 수 있다고 할 수 있다.

> LSP는 아키텍처 수준가지 확장할 수 있고, 반드시 확장해야만 한다. 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 매커니즘을 추가해야 할 수 있기 때문이다.
