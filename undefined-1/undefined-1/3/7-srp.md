# 7장 SRP: 단일 책임 원칙

## 다시 정의하는 SRP

내가 SRP 를 너무 단편적으로 알고 있었다. 내가 이해했던 SRP 는 사실상 '세밀한 응집성' 수준이었고, 이번 내용을 통해 SRP 에 대한 오해를 수정했다. 저자도 SRP 의 개념이 꽤 잘못 알려져 있다고 말하고 있다.

> 하나의 모듈은 오직 하나의 액터에 대해서만 책임져야 한다.

이게 SRP 이다. 그럼 모듈과 액터에 대해서 정리해보자.



### SRP 에서 말하는 모듈이란

단순하게 함수와 데이터 구조로 구성된 응집된 집합. 여기서 핵심은 응집성이다. 단일 액터를 책임지는 코드를 묶어주는 힘이 응집성이다.



### SRP 에서 말하는 액터란

변경을 요청하는 한 명 이상의 사람들 및 이해관계자인데 이를 집단으로 인식할 수 있다. 즉, 액터란 수가 1이든 다수이든 결국 대표 및 집단으로 인식될 수 있는 '변경 요청 주체' 이다.

조금 더 자세히 설명하자면 여기서 액터는 정말 실제로 존재하는 현실의 누군가이다. 시스템이 동일한 방식으로 변경되기를 원하는 사용자나 이해관계자 혹은 사용자들 또는 이해관계자들(그래서 집단) 이다.

더 직관적인 표현을 해보면 '정책 변경을 요청하는 현업(현업집단 내지 부서)' 정도가 되겠다.



## SRP 를 위반하는 사례를 통해 알아보는 SRP(정의를 어겼다고 가정해보자)

중요하니 다시 적자면 SRP 원칙은 아래와 같다.

> 하나의 모듈은 오직 하나의 액터에 대해서만 책임져야 한다.

그럼 하나의 모듈이 두 개의 액터에 대해서 책임지면 이를 어기게 되는 것이 되겠다.



<figure><img src="../../../.gitbook/assets/2023. 4. 5. - 0 5 (1).jpg" alt=""><figcaption></figcaption></figure>

책에 나온 도표인데 액터가 셋이다.

calculatePay() 는 회계팀에서 기능 정의를 하고 CFO 보고를 위해 사용한다. reportHour() 는 인사팀에서 기능을 정의하고 사용하며, COO 보고를 위해 사용한다. save() 는 DBA 가 기능을 정의하고 CTO 보고를 위해 사용한다고 한다.

이미 SRP 가 위반되었다. 세 액터를 Employee 라는 모듈 하나가 책임지고 있는 것이다.



<figure><img src="../../../.gitbook/assets/2023. 4. 5. - 0 6 (1).jpg" alt=""><figcaption></figcaption></figure>

현재 위와 같이 calculatePay 와 reportHours가 정규 근무 시간을 계산하는 메소드를 공유하고 있다고 치자. 이 때 '근무 시간에 대한 인식' 이 CFO 측에서 바뀌어서 COO 와 인식하는 근무 시간이 다르게 계산 되어야 하는 상황인 경우가 있을 수 있다.

결국 이는 서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기에 발생한다. SRP 를 적용한다면 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.



## 해결책은 결국 분리하는 방법

책에서는 두 가지 해결책을 제시하고 있는데, 일단 첫번째를 보자.

<figure><img src="../../../.gitbook/assets/image (162).png" alt=""><figcaption></figcaption></figure>

일단 연산에 필요한 데이터를 DTO 로 빼서 오직 데이터를 담는 그릇으로 쓰고, 연산은 외부 클래스에서 만들어서 사용하는 경우다. 이렇게 할 경우 지금 문제가 되는 근무 시간 계산과 관련해서 각 리포터에서 알아서 구현하면 된다.

하지만 이렇게 하면 각 리포터를 따로 추적해야하기 때문에 관리가 어려우니 아래와 같이 facade 계층을 만들어서 이곳에서 모두를 관장하고 각각은 따로 리포터로 분리 구현하면 된다.

<figure><img src="../../../.gitbook/assets/image (163).png" alt=""><figcaption></figcaption></figure>

핵심은 Employee 에 있던 각 세 메소드가 클래스로 분리되어서 따로 관리 된다는 것이다. 지금 이게 근무시간 계산에 있어서 정책이 CFO 와 COO 가 갈려서 그렇지 사실 이전 정책처럼 같다 그러면 굉장히 불필요하게 쪼갠 형태가 되는 것이긴 하다.

이전 정책처럼 같다면 각각의 리포터에서 근무 시간 계산에 관한 중복 코드가 생기거나 여전히 Employee 든 어디든 근무 시간을 계산하는 메소드를 구현해두고 두 액터가 하나에 의존하는 형태가 생길 수 밖에 없다.

과연 실무를 할 때 이렇게 까지(어찌보면 '지금 굳이 이렇게 까지 분리한다고?' 라는 의문이 생길 수 밖에 없는 수준의 분리) 할 수 있을지 모르겠다. 왜냐하면 팀원들의 합의가 여기까지 도달 할 수 있을지도 의문이고, 나역시 좀 불필요한 것 같다는 생각도 든다.

위와 같은 방식도 단점이 있다. 도메인 규칙을 Employee 하나에서 모두 제어 하고 싶은데 저렇게 되면 클래스별로 분리 추적을 해야한다는 단점이다. 그래서 아래와 같이 분리라는 맥락은 유사하지만 여전히 Employee 내에서 처리하는 방법도 있다.

<figure><img src="../../../.gitbook/assets/2023. 4. 5. - 0 8 (1).jpg" alt=""><figcaption></figcaption></figure>

이것은 따로 디자인된 객체에 의존하는 형태로 처리하는 것인데 내부에서 아마 분기가 발생하거나 분기 없이 다른 구현체를 주입해서 처리를 할 수도 있을 것 같다.

아니면 Employee 메소드에 그대로 세 함수들을 선언해두되, 각 함수를 외부에서 함수를 파라미터로 주입 받아서 처리하게 하면 좋을 것 같다. 그러면 여전히 Employee 하나가 모든 도메인 규칙을 관장하는 형태를 그대로 유지할 수 있으면서도, 각 경우에 대한 다른 처리를 일관되게 수행할 수 있을 것이다.

어차피 CFO 든 COO 든 적어도 '어떤 액터가 요청했는지' 에 대한 것은 진입 포인트의 차이나 인증 과정에서 알 수 있으니 결국 호출 수행 주체에 따라서 다른 함수를 인자로 넘겨서 내부에서 처리하면 그만이다.

그러면 이게 SRP 를 지킨거냐고 한다면 일단 형태를 분리를 해뒀기 때문에 지킨 것이라고 볼 수 있을 것 같다. 다시 원칙을 살펴보자.&#x20;

> 하나의 모듈은 오직 하나의 액터에 대해서만 책임져야 한다.

저렇게 나눠 놓으면 수정이 발생하면 그것만 수정하면 되니까 SRP 가 지켜진 것이라고 볼 수 있다. 위 정의를 만족하니까.
