# CH04 엔티티 매핑

## 엔티티 매핑

이번 장은 제목 그대로 엔티티 레벨에서 매핑을 어떻게 시키는지에 관한 이야기이다. 여기서 나는 '매핑' 이라는 단어의 의미를 짚어보고 싶다. 왜 여기서 '매핑' 이라는 단어를 사용 한 것일까?

현재 JPA 를 학습하고 있고 JPA 는 자바 진영의 ORM 기술 명세이다. ORM 의 의미에 대해서 먼저 잠깐 짚어보자. 아래는 백기선님 강의 노트에 내가 적은 필기의 일부이다.

> [ORM](https://www.techopedia.com/definition/24200/object-relational-mapping--orm) 의 의미에 대해서 정의된 자료는 많았지만 강의에서 말하고 있는 의미와 가장 유사하고 내가 생각하기에 가장 적절한 표현이라고 생각되는 것은 아래와 같다.

> Object-relational mapping (ORM) is a programming technique in which a metadata descriptor is used to connect object code to a relational database. Object code is written in object-oriented programming (OOP) languages such as Java or C#. ORM converts data between type systems that are unable to coexist within relational databases and OOP languages.

> 다시 말해, ORM 은 우리가 데이터를 영속화 할 때 RDBMS를 이용하고 싶은 상황인데 코드는 객체 지향 언어로 작성을 해야할 경우 이를 해결해주는 기술 이라고 말할 수 있는 것이다.
>
> ORM 은 메타 데이터를 통해서 특정한 object와 특정한 RDBMS 의 테이블(relational) 을 매핑해주고, 같은 맥락에서 특정한 object 의 특정한 필드와 특정한 테이블의 특정한 컬럼을 매핑해주는 기술인 것이다.
>
> 여기서 말하는 메타 데이터란 @Table, @Column 등으로 사용했던 코드들을 의미한다.

위와 같은 의미에서 Object 와 Relational 의 사이에 '매핑' 이 필요한 것이다. 그리고 매핑의 기준이 되는 것은 메타데이터이다. 이 장에서는 엔티티 레벨에서의 매핑을 위해서 어떤 메타데이터들이 어떤식으로 작동되어 결국 매핑에 사용되는지를 학습한다.

## @Entity&#x20;

테이블과 매핑할 클래스라는 것을 JPA 에 인식 시키는 메타 데이터이다. 속성으로 name 이 있는데 기본값으로 클래스 명을 사용한다. 사실 엔티티의 이름이 무엇인지는 경험상 하나도 중요하지 않았다. 엔티티의 이름은 결국 아래에서 알아볼 @Table 의 name 설정에 사용된다. 기본적으로 @Table 의 name 은 따로 설정해주지 않으면(Implicit Naming Strategy) 엔티티의 name 을 스네이크 케이스로 변환하는 전략을 사용한다.

기억해야할 가장 중요한 부분은 엔티티로 설정된 클래스는 기본 생성자가 반드시 필요하다는 것이다. JPA 가 엔티티를 생성할 때 리플랙션을 사용하기 때문에 기본 생성자를 반드시 만들어 줘야한다. 사실 만들지 않으면 이미 컴파일 에러가 나기 때문에 무조건 만들게는 되어 있는데 이유를 알고 있도록 하자.

* @Entity 의 name 값은 디폴트로 클래스 명이 사용되며 이는 @Table 의 name 을 Implicit Naming Strategy 로 정할 경우 스네이크 케이스로 변환되어 사용된다.
* JPA는 엔티티 생성시 리플랙션을 이용하므로 @Entity 로 설정해주는 클래스는 반드시 기본 생성자가 필요하다.

## @Table

name 속성이 어떻게 정해지는지에 관해서는 @Entity 에서 이미 알아보았다. 나는 개인적으로 명시적으로 드러내어 적어주는 것을 더 선호한다.

uniqueConstraints 속성으로 유니크 제약조건을 만들 수 있다. 개인적으로 대체키를 사용하는 경우 굳이 두 컬럼 이상을 복합키로 설정할 필요성을 느꼈던 적은 없다.

책에서는 언급되지 않았는데 indexes 속성을 통해서 인덱스 설정을 할 수 있다. 아래는 인덱스 설정 예시이다.

```java
@Table(
        name = "auction",
        indexes = {
                @Index(name = "idx_endTime", columnList = "endTime"),
                @Index(name = "idx_auctionStatusType", columnList = "auctionStatusType"),
                @Index(name = "idx_auctionType", columnList = "auctionType")
        })
```

## hibernate.ddl-auto 옵션별 정리

회사에서는 운영 DB 에 접속할때 어플리케이션에서 사용하는 계정이 DDL 권한 자체가 없었어서 사실 운영환경에서는 해당 속성이 큰 의미가 없었다. 하지만 그럼에도 validate 와 같은 속성은 유용하게 사용될 수 있기도 하고, 회사 규모가 작다면 권한에 자유도가 크기 때문에 ddl-auto 속성에 대해서 세세하게 알고 있는 것이 좋다.

| 옵션     | 설명               |
| ------ | ---------------- |
| create | DROP + CREATE ㅣd |
|        |                  |
|        |                  |
|        |                  |















































