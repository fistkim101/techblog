# CH08 프록시와 연관관계 관리

## 프록시

JPA 에서는 프록시가 많이 활용되고 있다. 프록시 자체에 대해서 짚고 넘어가면 좋을 것 같다.

[프록시라는 영어단어의 뜻](https://en.dict.naver.com/#/entry/enko/2ba09ebcdb6a4c22bd17e98caae1f4c5) 자체가 ‘대리인’, ‘대리물’ 이다. 디자인 패턴에서도 [프록시 패턴](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9D%EC%8B%9C\_%ED%8C%A8%ED%84%B4) 이 존재하는데 하이버네이트에서도 프록시 패턴과 같은 방식으로 지연로딩을 제공한다. 위 링크에 있는 프록시 패턴의 코드를 남긴다.

쉽게 표현하면 일단은 겉보기에는 실제와 일치하는 번듯한 것을 제공하고, 실제로 이걸 까보려 하면 이제야 실제 자원을 가져와 이를 통해서 필요한 것을 제공하는 것이다.

코드에서 확인할 수 있지만 대리인 객체가 실체에 대한 참조를 가지고 있고, 껍데기만 제공한다. 그리고 실제로 실체의 자원이 필요한 경우 그제서야 실체를 로드하여 참조에 실체에 대한 주소값을 할당하여 기능을 수행하는 것이다.

결과적으로 사용하는 입장에서는 해당 객체가 프록시인지 아닌지는 알 필요가 없고 그냥 사용하면 된다. 왜냐하면 알아서 프록시 객체에서 실체가 필요한 경우에 로드를 해서 필요한 자원을 제공해줄 것이기 때문이다.

<figure><img src="../../.gitbook/assets/image (20).png" alt=""><figcaption></figcaption></figure>

```java
import java.util.*;

interface Image {
    public void displayImage();
}

//on System A
class RealImage implements Image {
    private String filename;
    public RealImage(String filename) {
        this.filename = filename;
        loadImageFromDisk();
    }

    private void loadImageFromDisk() {
        System.out.println("Loading   " + filename);
    }

    @Override
    public void displayImage() {
        System.out.println("Displaying " + filename);
    }
}

//on System B
class ProxyImage implements Image {
    private String filename;
    private Image image;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    @Override
    public void displayImage() {
        if (image == null)
           image = new RealImage(filename);

        image.displayImage();
    }
}

class ProxyExample {
    public static void main(String[] args) {
        Image image1 = new ProxyImage("HiRes_10MB_Photo1");
        Image image2 = new ProxyImage("HiRes_10MB_Photo2");

        image1.displayImage(); // loading necessary
        image2.displayImage(); // loading necessary
    }
}
```

## EntityManager의 프록시 핸들링

### EntityManager의 프록시 객체 생성 및 관리 특징

내부적으로 EntityManager 가 어떻게 프록시 객체를 할당하는지,  또 EntityManager 가 프록시 객체를 어떻게 관리하는지 정리해보자.

```java
@Override
    @Transactional
    public void run(ApplicationArguments args) throws Exception {
        final Member member = this.entityManager.getReference(Member.class, 1L);
        System.out.println("loaded : " + this.isLoaded(member));
        System.out.println("className : " + member.getClass().getName());

        member.getId();
        System.out.println("loaded : " + this.isLoaded(member));
        member.getName();
        System.out.println("loaded : " + this.isLoaded(member));
        System.out.println("className : " + member.getClass().getName());
    }

    private boolean isLoaded(Object object){
        return this.entityManagerFactory.getPersistenceUnitUtil().isLoaded(object);
    }
```

```bash
loaded : false
className : com.fistkim.springjpawhiteshipstudy.Member$HibernateProxy$63wbZVZy
loaded : false
Hibernate: 
    select
        member0_.id as id1_0_0_,
        member0_.name as name2_0_0_,
        member0_.team_id as team_id3_0_0_ 
    from
        member member0_ 
    where
        member0_.id=?
loaded : true
className : com.fistkim.springjpawhiteshipstudy.Member$HibernateProxy$63wbZVZy

```

#### EntityManager는 프록시 객체를 어떻게 할당하는가

위  코드에서 확인할 수 있듯이 entityManager는 아래 자원을 통해서 프록시 객체를 할당한다.

```java
public <T> T getReference(Class<T> entityClass, 
                              Object primaryKey);
```

#### &#x20;EntityManager 는 프록시 객체를 식별자 값으로 관리한다

로그를 보면 id를 가져오는 시점에는 초기화가 발생되지 않지만, name 을 가져오는 시점에는 초기화가 발생하는 것을 확인할 수 있다. EntityManager 가 프록시 객체에 대해서 식별값으로 관리하고 있으며, 식별값만 사용할 경우 이미 갖고 있으니까 초기화를 시킬 필요가 없음을 의미한다.

#### 초기화가 되었다 하더라도 프록시 객체는 트랜잭션 종료까지 계속 프록시 객체이다

초기화 여부와 상관없이 동일 트랜잭션 내에서 한 번 프록시 객체로 할당이 되었다면 트랜잭션 종료까지 계속 프록시 객체이다. 단지  초기화 여부에 따라 프록시 객체 내부에 실체에 대한 참조값이 할당이 되었느냐 안되었느냐의 차이가 있는 것이다.

### 조회 예제로 알아보는 EntityManager의 프록시 객체 활용 원리

```java
// MemberProxy
Member member = em.getReference(Member.class, 1L);
member.getName();
```

```java
class MemberProxy extends Member {

    Member target = null; 
    
    public String getName(){
    
       if(target == null){
       // 초기화 요청, DB 조회, 실제 엔티티 생성 및 참조 보관
       this.target = ...;        
       }
       
       return this.target.getName();
   }    
}            
```

<figure><img src="../../.gitbook/assets/image (24).png" alt=""><figcaption></figcaption></figure>

만약에 프록시 객체에 할당하고자 하는 실체가 이미 영속성 컨텍스트에 존재한다면 데이터베이스를 조회할 일이 없이 바로 초기화가 될 것이다.

같은 맥락에서 만약 영속성 컨택스트의 도움을 받지 못하는 상황에 초기화 요청이 발생할 경우 LazyInitializationException 이 발생한다.















