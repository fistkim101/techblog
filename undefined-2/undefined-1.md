# 데이터베이스 구성 및 작동 흐름

## 쿼리 실행 구조도

<figure><img src="../.gitbook/assets/image (1) (2) (1).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../.gitbook/assets/image (23) (2) (1) (2).png" alt=""><figcaption></figcaption></figure>

백엔드 상에서 데이터베이스와 통신을 하는 것을 가정하면 위 그림에서 사용자가 곧 백엔드 서버가 된다.

## 파서

> MySQL’s parser, like many others, consists of two parts: the _lexical scanner_ and the _grammar rule module_. The lexical scanner breaks the entire query into tokens (elements that are indivisible, such as column names), while the grammar rule module finds a combination of SQL grammar rules that produce this sequence, and executes the code associated with those rules. In the end, a parse tree is produced, which can now be used by the optimizer.
>
> Unlike some parsers, which translate the textual representation of the query into byte code, MySQL’s parser converts it directly into internal interlinked C/C++ structures in the program memory.

&#x20;파서의 역할은 사용자의 요청으로 들어온 쿼리 문장을 토큰(MySQL 이 인식할 수 있는 최소 단위의 어휘나 기호)로 분리해 [트리 형태의 구조](https://ko.wikipedia.org/wiki/%EC%B6%94%EC%83%81\_%EA%B5%AC%EB%AC%B8\_%ED%8A%B8%EB%A6%AC)로 만들어내는 작업을 한다. 문법 오류는 이 과정에서 발견 된다.

* 쿼리를 토큰화
* 추상 구문 트리 생성(이 과정에서 문법 오류 발견)

## 전처리기

파서 과정에서 만들어진 추상 구문 트리를 통해서 토큰마다 테이블, 컬럼, 내장함수 등을 매핑해서 각 객체의 존재 여부 혹은 접근 권한을 확인한다.

## 옵티마이저

규칙 기반 옵티마이저와 비용 기반 옵티마이저가 존재한다.

### 규칙 기반 옵티마이저(Rule-based Optimizer)

이 옵티마이저는 미리 정의된 규칙에 따라 실행 계획을 선택한다. 각 규칙은 쿼리의 구조와 조건을 분석하여 실행 계획을 결정한다. Rule-based Optimizer는 MySQL 5.6 이전 버전에서 사용되었으며, 현재는 deprecated(사용 비권장) 상태이다.

### 비용 기반 옵티마이저(Cost-based Optimizer)

이 옵티마이저는 실행 계획의 비용을 고려하여 최적의 실행 계획을 선택한다. 비용은 테이블의 크기, 인덱스 통계, 디스크 I/O 등을 고려하여 추정한다. Cost-based Optimizer는 MySQL 5.7 버전부터 기본 옵티마이저로 사용되었으며, 현재는 주로 사용되고 있는 옵티마이저이다.

#### (+추가) Enhanced Cost-based Optimizer (향상된 비용 기반 옵티마이저)

이 옵티마이저는 MySQL 8.0 버전부터 도입되다. Enhanced Cost-based Optimizer는 Cost-based Optimizer의 개선된 버전으로, 더 정확한 통계 정보, 인덱스 선택 기능, 조인 최적화 등을 제공한다. 이를 통해 더 효율적인 실행 계획을 선택할 수 있다.

### 비용 기반 옵티마이저의 비용 계산 방식

비용 기반 옵티마이저는 여러가지 실행 계획을 생성하고 각 실행 계획의 비용을 '예상'하여 가장 적은 비용의 실행 계획을 채택한다. 각 실행 계획의 비용을 예상할때 고려하는 요소들은 아래와 같다.

1. 테이블 크기: 테이블의 크기는 데이터베이스의 I/O 비용을 추정하는 데 사용된다. 예를 들어, 더 큰 테이블에 접근하는 것은 더 많은 디스크 I/O 작업을 필요로하므로 비용이 높게 평가될 수 있다.
2. 인덱스 통계: 인덱스 통계 정보는 인덱스 카디널리티, 값의 분포 등을 포함하며, 비용 계산에 사용된다. [인덱스의 선택성과 중복성](#user-content-fn-1)[^1]을 고려하여 인덱스의 비용을 추정할 수 있다.
3. 디스크 I/O 비용: 디스크 I/O 작업은 데이터베이스에서 데이터에 접근하는 데에 소요되는 주요 비용이다. 비용 기반 옵티마이저는 데이터의 양과 디스크 I/O 비용을 고려하여 테이블 스캔, 인덱스 스캔 등의 작업에 대한 비용을 추정한다.
4. 메모리 및 CPU 비용: 옵티마이저는 메모리 및 CPU 사용량도 고려하여 실행 계획의 비용을 결정할 수 있다. 예를 들어, 메모리 정렬이나 정렬 작업에 필요한 CPU 연산 등이 비용에 반영될 수 있다.

### 테이블 접근시 디스크 IO 작업의 의미

> 테이블에 접근하는 것이 디스크 I/O 작업을 필요로 하는 이유는 테이블 데이터가 디스크에 저장되기 때문입니다. 디스크는 데이터베이스가 영구적으로 데이터를 보존하기 위해 사용되는 기본 저장 매체입니다. 따라서, 데이터베이스에서 테이블에 접근하려면 디스크에서 데이터를 읽어와야 합니다.
>
>
>
> 테이블에 접근하기 위해서는 디스크 I/O 작업이 수행됩니다. 이 작업은 디스크에서 데이터 블록을 읽어와 메모리로 가져오는 것을 의미합니다. 데이터가 디스크에 저장되어 있으므로, 테이블의 데이터를 읽거나 수정하려면 해당 데이터가 저장된 디스크 블록을 읽어와야 합니다.
>
>
>
> 디스크 I/O 작업은 상대적으로 느린 작업으로 간주됩니다. 디스크는 메모리에 비해 접근 시간이 오래 걸리며, 데이터의 크기가 크고 디스크의 회전 속도나 액세스 시간에 영향을 받기 때문입니다. 따라서, 데이터베이스의 성능을 향상시키기 위해서는 디스크 I/O 작업을 최소화하고, 데이터를 캐시 메모리에 유지하여 디스크 액세스를 최소화하는 것이 중요합니다. 이를 위해 인덱스를 사용하거나 메모리 버퍼 캐시를 적절히 활용하는 등의 기법이 사용됩니다.
>
>
>
> 요약하자면, 테이블에 접근하는 것이 디스크 I/O 작업을 필요로 하는 이유는 데이터가 디스크에 저장되어 있기 때문입니다. 디스크 I/O 작업은 상대적으로 느린 작업이므로, 데이터베이스 성능을 향상시키기 위해서는 디스크 액세스를 최소화하는 최적화 기법을 적용해야 합니다.

[^1]: 인덱스의 중복성은 인덱스에서 사용되는 키(Key)의 중복 여부를 나타냅니다. 일반적으로 인덱스는 유일성을 가지며, 동일한 키 값이 중복되지 않도록 설계됩니다. 이는 특정 값을 빠르게 찾을 수 있도록 보장하는 역할을 합니다.



    예를 들어, 특정 테이블의 인덱스가 고객의 이메일 주소를 키로 사용한다고 가정해보겠습니다. 인덱스의 중복성이 없는 경우, 각 이메일 주소는 한 번만 인덱스에 등록되어야 합니다. 이렇게 하면 특정 이메일 주소로 레코드를 빠르게 찾을 수 있습니다.



    반면에, 인덱스의 중복성이 허용되는 경우, 동일한 키 값이 여러 개의 인덱스 항목에 중복해서 저장될 수 있습니다. 이 경우에는 동일한 키 값을 가진 레코드가 여러 개의 인덱스 엔트리에 연결될 수 있습니다.



    인덱스의 중복성을 허용하는 경우에는 동일한 키 값을 가진 레코드가 여러 개 존재할 수 있으며, 이는 특정 값을 검색할 때 여러 개의 레코드가 반환될 수 있다는 의미입니다. 따라서 인덱스의 중복성은 특정 값을 찾는 데에 있어서 정확성과 유일성을 보장하는 역할을 합니다.



    일반적으로 대부분의 데이터베이스 시스템은 인덱스의 중복성을 허용하지 않습니다. 이는 효율적인 데이터 검색을 위해 중복된 키 값을 가지는 인덱스를 사용하는 것을 방지하기 위함입니다.
